// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tinysns.proto

#ifndef PROTOBUF_tinysns_2eproto__INCLUDED
#define PROTOBUF_tinysns_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_tinysns_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsNoMessageImpl();
void InitDefaultsNoMessage();
void InitDefaultsServerInfoImpl();
void InitDefaultsServerInfo();
void InitDefaultsUserImpl();
void InitDefaultsUser();
void InitDefaultsFollowOpImpl();
void InitDefaultsFollowOp();
void InitDefaultsReplyStatusImpl();
void InitDefaultsReplyStatus();
void InitDefaultsPostingImpl();
void InitDefaultsPosting();
void InitDefaultsNewPostingImpl();
void InitDefaultsNewPosting();
inline void InitDefaults() {
  InitDefaultsNoMessage();
  InitDefaultsServerInfo();
  InitDefaultsUser();
  InitDefaultsFollowOp();
  InitDefaultsReplyStatus();
  InitDefaultsPosting();
  InitDefaultsNewPosting();
}
}  // namespace protobuf_tinysns_2eproto
namespace tinysns {
class FollowOp;
class FollowOpDefaultTypeInternal;
extern FollowOpDefaultTypeInternal _FollowOp_default_instance_;
class NewPosting;
class NewPostingDefaultTypeInternal;
extern NewPostingDefaultTypeInternal _NewPosting_default_instance_;
class NoMessage;
class NoMessageDefaultTypeInternal;
extern NoMessageDefaultTypeInternal _NoMessage_default_instance_;
class Posting;
class PostingDefaultTypeInternal;
extern PostingDefaultTypeInternal _Posting_default_instance_;
class ReplyStatus;
class ReplyStatusDefaultTypeInternal;
extern ReplyStatusDefaultTypeInternal _ReplyStatus_default_instance_;
class ServerInfo;
class ServerInfoDefaultTypeInternal;
extern ServerInfoDefaultTypeInternal _ServerInfo_default_instance_;
class User;
class UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace tinysns
namespace tinysns {

// ===================================================================

class NoMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tinysns.NoMessage) */ {
 public:
  NoMessage();
  virtual ~NoMessage();

  NoMessage(const NoMessage& from);

  inline NoMessage& operator=(const NoMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NoMessage(NoMessage&& from) noexcept
    : NoMessage() {
    *this = ::std::move(from);
  }

  inline NoMessage& operator=(NoMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NoMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NoMessage* internal_default_instance() {
    return reinterpret_cast<const NoMessage*>(
               &_NoMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(NoMessage* other);
  friend void swap(NoMessage& a, NoMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NoMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  NoMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NoMessage& from);
  void MergeFrom(const NoMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NoMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tinysns.NoMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_tinysns_2eproto::TableStruct;
  friend void ::protobuf_tinysns_2eproto::InitDefaultsNoMessageImpl();
};
// -------------------------------------------------------------------

class ServerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tinysns.ServerInfo) */ {
 public:
  ServerInfo();
  virtual ~ServerInfo();

  ServerInfo(const ServerInfo& from);

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerInfo(ServerInfo&& from) noexcept
    : ServerInfo() {
    *this = ::std::move(from);
  }

  inline ServerInfo& operator=(ServerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerInfo* internal_default_instance() {
    return reinterpret_cast<const ServerInfo*>(
               &_ServerInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ServerInfo* other);
  friend void swap(ServerInfo& a, ServerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ServerInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServerInfo& from);
  void MergeFrom(const ServerInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ip = 1;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // string port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  const ::std::string& port() const;
  void set_port(const ::std::string& value);
  #if LANG_CXX11
  void set_port(::std::string&& value);
  #endif
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  ::std::string* mutable_port();
  ::std::string* release_port();
  void set_allocated_port(::std::string* port);

  // @@protoc_insertion_point(class_scope:tinysns.ServerInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr port_;
  mutable int _cached_size_;
  friend struct ::protobuf_tinysns_2eproto::TableStruct;
  friend void ::protobuf_tinysns_2eproto::InitDefaultsServerInfoImpl();
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tinysns.User) */ {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(User&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(User* other);
  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline User* New() const PROTOBUF_FINAL { return New(NULL); }

  User* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(User* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:tinysns.User)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  mutable int _cached_size_;
  friend struct ::protobuf_tinysns_2eproto::TableStruct;
  friend void ::protobuf_tinysns_2eproto::InitDefaultsUserImpl();
};
// -------------------------------------------------------------------

class FollowOp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tinysns.FollowOp) */ {
 public:
  FollowOp();
  virtual ~FollowOp();

  FollowOp(const FollowOp& from);

  inline FollowOp& operator=(const FollowOp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FollowOp(FollowOp&& from) noexcept
    : FollowOp() {
    *this = ::std::move(from);
  }

  inline FollowOp& operator=(FollowOp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FollowOp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FollowOp* internal_default_instance() {
    return reinterpret_cast<const FollowOp*>(
               &_FollowOp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(FollowOp* other);
  friend void swap(FollowOp& a, FollowOp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FollowOp* New() const PROTOBUF_FINAL { return New(NULL); }

  FollowOp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FollowOp& from);
  void MergeFrom(const FollowOp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FollowOp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string follow = 2;
  void clear_follow();
  static const int kFollowFieldNumber = 2;
  const ::std::string& follow() const;
  void set_follow(const ::std::string& value);
  #if LANG_CXX11
  void set_follow(::std::string&& value);
  #endif
  void set_follow(const char* value);
  void set_follow(const char* value, size_t size);
  ::std::string* mutable_follow();
  ::std::string* release_follow();
  void set_allocated_follow(::std::string* follow);

  // @@protoc_insertion_point(class_scope:tinysns.FollowOp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr follow_;
  mutable int _cached_size_;
  friend struct ::protobuf_tinysns_2eproto::TableStruct;
  friend void ::protobuf_tinysns_2eproto::InitDefaultsFollowOpImpl();
};
// -------------------------------------------------------------------

class ReplyStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tinysns.ReplyStatus) */ {
 public:
  ReplyStatus();
  virtual ~ReplyStatus();

  ReplyStatus(const ReplyStatus& from);

  inline ReplyStatus& operator=(const ReplyStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReplyStatus(ReplyStatus&& from) noexcept
    : ReplyStatus() {
    *this = ::std::move(from);
  }

  inline ReplyStatus& operator=(ReplyStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplyStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReplyStatus* internal_default_instance() {
    return reinterpret_cast<const ReplyStatus*>(
               &_ReplyStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ReplyStatus* other);
  friend void swap(ReplyStatus& a, ReplyStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReplyStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  ReplyStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReplyStatus& from);
  void MergeFrom(const ReplyStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReplyStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:tinysns.ReplyStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  mutable int _cached_size_;
  friend struct ::protobuf_tinysns_2eproto::TableStruct;
  friend void ::protobuf_tinysns_2eproto::InitDefaultsReplyStatusImpl();
};
// -------------------------------------------------------------------

class Posting : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tinysns.Posting) */ {
 public:
  Posting();
  virtual ~Posting();

  Posting(const Posting& from);

  inline Posting& operator=(const Posting& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Posting(Posting&& from) noexcept
    : Posting() {
    *this = ::std::move(from);
  }

  inline Posting& operator=(Posting&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Posting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Posting* internal_default_instance() {
    return reinterpret_cast<const Posting*>(
               &_Posting_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Posting* other);
  friend void swap(Posting& a, Posting& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Posting* New() const PROTOBUF_FINAL { return New(NULL); }

  Posting* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Posting& from);
  void MergeFrom(const Posting& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Posting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string posting = 3;
  void clear_posting();
  static const int kPostingFieldNumber = 3;
  const ::std::string& posting() const;
  void set_posting(const ::std::string& value);
  #if LANG_CXX11
  void set_posting(::std::string&& value);
  #endif
  void set_posting(const char* value);
  void set_posting(const char* value, size_t size);
  ::std::string* mutable_posting();
  ::std::string* release_posting();
  void set_allocated_posting(::std::string* posting);

  // int64 posting_time = 2;
  void clear_posting_time();
  static const int kPostingTimeFieldNumber = 2;
  ::google::protobuf::int64 posting_time() const;
  void set_posting_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tinysns.Posting)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr posting_;
  ::google::protobuf::int64 posting_time_;
  mutable int _cached_size_;
  friend struct ::protobuf_tinysns_2eproto::TableStruct;
  friend void ::protobuf_tinysns_2eproto::InitDefaultsPostingImpl();
};
// -------------------------------------------------------------------

class NewPosting : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tinysns.NewPosting) */ {
 public:
  NewPosting();
  virtual ~NewPosting();

  NewPosting(const NewPosting& from);

  inline NewPosting& operator=(const NewPosting& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewPosting(NewPosting&& from) noexcept
    : NewPosting() {
    *this = ::std::move(from);
  }

  inline NewPosting& operator=(NewPosting&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewPosting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewPosting* internal_default_instance() {
    return reinterpret_cast<const NewPosting*>(
               &_NewPosting_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(NewPosting* other);
  friend void swap(NewPosting& a, NewPosting& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewPosting* New() const PROTOBUF_FINAL { return New(NULL); }

  NewPosting* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewPosting& from);
  void MergeFrom(const NewPosting& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewPosting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string posting = 2;
  void clear_posting();
  static const int kPostingFieldNumber = 2;
  const ::std::string& posting() const;
  void set_posting(const ::std::string& value);
  #if LANG_CXX11
  void set_posting(::std::string&& value);
  #endif
  void set_posting(const char* value);
  void set_posting(const char* value, size_t size);
  ::std::string* mutable_posting();
  ::std::string* release_posting();
  void set_allocated_posting(::std::string* posting);

  // @@protoc_insertion_point(class_scope:tinysns.NewPosting)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr posting_;
  mutable int _cached_size_;
  friend struct ::protobuf_tinysns_2eproto::TableStruct;
  friend void ::protobuf_tinysns_2eproto::InitDefaultsNewPostingImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NoMessage

// -------------------------------------------------------------------

// ServerInfo

// string ip = 1;
inline void ServerInfo::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerInfo::ip() const {
  // @@protoc_insertion_point(field_get:tinysns.ServerInfo.ip)
  return ip_.GetNoArena();
}
inline void ServerInfo::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tinysns.ServerInfo.ip)
}
#if LANG_CXX11
inline void ServerInfo::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tinysns.ServerInfo.ip)
}
#endif
inline void ServerInfo::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tinysns.ServerInfo.ip)
}
inline void ServerInfo::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tinysns.ServerInfo.ip)
}
inline ::std::string* ServerInfo::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:tinysns.ServerInfo.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerInfo::release_ip() {
  // @@protoc_insertion_point(field_release:tinysns.ServerInfo.ip)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerInfo::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:tinysns.ServerInfo.ip)
}

// string port = 2;
inline void ServerInfo::clear_port() {
  port_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerInfo::port() const {
  // @@protoc_insertion_point(field_get:tinysns.ServerInfo.port)
  return port_.GetNoArena();
}
inline void ServerInfo::set_port(const ::std::string& value) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tinysns.ServerInfo.port)
}
#if LANG_CXX11
inline void ServerInfo::set_port(::std::string&& value) {
  
  port_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tinysns.ServerInfo.port)
}
#endif
inline void ServerInfo::set_port(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tinysns.ServerInfo.port)
}
inline void ServerInfo::set_port(const char* value, size_t size) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tinysns.ServerInfo.port)
}
inline ::std::string* ServerInfo::mutable_port() {
  
  // @@protoc_insertion_point(field_mutable:tinysns.ServerInfo.port)
  return port_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerInfo::release_port() {
  // @@protoc_insertion_point(field_release:tinysns.ServerInfo.port)
  
  return port_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerInfo::set_allocated_port(::std::string* port) {
  if (port != NULL) {
    
  } else {
    
  }
  port_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), port);
  // @@protoc_insertion_point(field_set_allocated:tinysns.ServerInfo.port)
}

// -------------------------------------------------------------------

// User

// string username = 1;
inline void User::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::username() const {
  // @@protoc_insertion_point(field_get:tinysns.User.username)
  return username_.GetNoArena();
}
inline void User::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tinysns.User.username)
}
#if LANG_CXX11
inline void User::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tinysns.User.username)
}
#endif
inline void User::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tinysns.User.username)
}
inline void User::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tinysns.User.username)
}
inline ::std::string* User::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:tinysns.User.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_username() {
  // @@protoc_insertion_point(field_release:tinysns.User.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:tinysns.User.username)
}

// -------------------------------------------------------------------

// FollowOp

// string username = 1;
inline void FollowOp::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FollowOp::username() const {
  // @@protoc_insertion_point(field_get:tinysns.FollowOp.username)
  return username_.GetNoArena();
}
inline void FollowOp::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tinysns.FollowOp.username)
}
#if LANG_CXX11
inline void FollowOp::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tinysns.FollowOp.username)
}
#endif
inline void FollowOp::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tinysns.FollowOp.username)
}
inline void FollowOp::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tinysns.FollowOp.username)
}
inline ::std::string* FollowOp::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:tinysns.FollowOp.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FollowOp::release_username() {
  // @@protoc_insertion_point(field_release:tinysns.FollowOp.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FollowOp::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:tinysns.FollowOp.username)
}

// string follow = 2;
inline void FollowOp::clear_follow() {
  follow_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FollowOp::follow() const {
  // @@protoc_insertion_point(field_get:tinysns.FollowOp.follow)
  return follow_.GetNoArena();
}
inline void FollowOp::set_follow(const ::std::string& value) {
  
  follow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tinysns.FollowOp.follow)
}
#if LANG_CXX11
inline void FollowOp::set_follow(::std::string&& value) {
  
  follow_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tinysns.FollowOp.follow)
}
#endif
inline void FollowOp::set_follow(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  follow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tinysns.FollowOp.follow)
}
inline void FollowOp::set_follow(const char* value, size_t size) {
  
  follow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tinysns.FollowOp.follow)
}
inline ::std::string* FollowOp::mutable_follow() {
  
  // @@protoc_insertion_point(field_mutable:tinysns.FollowOp.follow)
  return follow_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FollowOp::release_follow() {
  // @@protoc_insertion_point(field_release:tinysns.FollowOp.follow)
  
  return follow_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FollowOp::set_allocated_follow(::std::string* follow) {
  if (follow != NULL) {
    
  } else {
    
  }
  follow_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), follow);
  // @@protoc_insertion_point(field_set_allocated:tinysns.FollowOp.follow)
}

// -------------------------------------------------------------------

// ReplyStatus

// string status = 1;
inline void ReplyStatus::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReplyStatus::status() const {
  // @@protoc_insertion_point(field_get:tinysns.ReplyStatus.status)
  return status_.GetNoArena();
}
inline void ReplyStatus::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tinysns.ReplyStatus.status)
}
#if LANG_CXX11
inline void ReplyStatus::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tinysns.ReplyStatus.status)
}
#endif
inline void ReplyStatus::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tinysns.ReplyStatus.status)
}
inline void ReplyStatus::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tinysns.ReplyStatus.status)
}
inline ::std::string* ReplyStatus::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:tinysns.ReplyStatus.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReplyStatus::release_status() {
  // @@protoc_insertion_point(field_release:tinysns.ReplyStatus.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReplyStatus::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:tinysns.ReplyStatus.status)
}

// -------------------------------------------------------------------

// Posting

// string username = 1;
inline void Posting::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Posting::username() const {
  // @@protoc_insertion_point(field_get:tinysns.Posting.username)
  return username_.GetNoArena();
}
inline void Posting::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tinysns.Posting.username)
}
#if LANG_CXX11
inline void Posting::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tinysns.Posting.username)
}
#endif
inline void Posting::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tinysns.Posting.username)
}
inline void Posting::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tinysns.Posting.username)
}
inline ::std::string* Posting::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:tinysns.Posting.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Posting::release_username() {
  // @@protoc_insertion_point(field_release:tinysns.Posting.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Posting::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:tinysns.Posting.username)
}

// int64 posting_time = 2;
inline void Posting::clear_posting_time() {
  posting_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Posting::posting_time() const {
  // @@protoc_insertion_point(field_get:tinysns.Posting.posting_time)
  return posting_time_;
}
inline void Posting::set_posting_time(::google::protobuf::int64 value) {
  
  posting_time_ = value;
  // @@protoc_insertion_point(field_set:tinysns.Posting.posting_time)
}

// string posting = 3;
inline void Posting::clear_posting() {
  posting_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Posting::posting() const {
  // @@protoc_insertion_point(field_get:tinysns.Posting.posting)
  return posting_.GetNoArena();
}
inline void Posting::set_posting(const ::std::string& value) {
  
  posting_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tinysns.Posting.posting)
}
#if LANG_CXX11
inline void Posting::set_posting(::std::string&& value) {
  
  posting_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tinysns.Posting.posting)
}
#endif
inline void Posting::set_posting(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  posting_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tinysns.Posting.posting)
}
inline void Posting::set_posting(const char* value, size_t size) {
  
  posting_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tinysns.Posting.posting)
}
inline ::std::string* Posting::mutable_posting() {
  
  // @@protoc_insertion_point(field_mutable:tinysns.Posting.posting)
  return posting_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Posting::release_posting() {
  // @@protoc_insertion_point(field_release:tinysns.Posting.posting)
  
  return posting_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Posting::set_allocated_posting(::std::string* posting) {
  if (posting != NULL) {
    
  } else {
    
  }
  posting_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), posting);
  // @@protoc_insertion_point(field_set_allocated:tinysns.Posting.posting)
}

// -------------------------------------------------------------------

// NewPosting

// string username = 1;
inline void NewPosting::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewPosting::username() const {
  // @@protoc_insertion_point(field_get:tinysns.NewPosting.username)
  return username_.GetNoArena();
}
inline void NewPosting::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tinysns.NewPosting.username)
}
#if LANG_CXX11
inline void NewPosting::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tinysns.NewPosting.username)
}
#endif
inline void NewPosting::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tinysns.NewPosting.username)
}
inline void NewPosting::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tinysns.NewPosting.username)
}
inline ::std::string* NewPosting::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:tinysns.NewPosting.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewPosting::release_username() {
  // @@protoc_insertion_point(field_release:tinysns.NewPosting.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewPosting::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:tinysns.NewPosting.username)
}

// string posting = 2;
inline void NewPosting::clear_posting() {
  posting_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewPosting::posting() const {
  // @@protoc_insertion_point(field_get:tinysns.NewPosting.posting)
  return posting_.GetNoArena();
}
inline void NewPosting::set_posting(const ::std::string& value) {
  
  posting_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tinysns.NewPosting.posting)
}
#if LANG_CXX11
inline void NewPosting::set_posting(::std::string&& value) {
  
  posting_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tinysns.NewPosting.posting)
}
#endif
inline void NewPosting::set_posting(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  posting_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tinysns.NewPosting.posting)
}
inline void NewPosting::set_posting(const char* value, size_t size) {
  
  posting_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tinysns.NewPosting.posting)
}
inline ::std::string* NewPosting::mutable_posting() {
  
  // @@protoc_insertion_point(field_mutable:tinysns.NewPosting.posting)
  return posting_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewPosting::release_posting() {
  // @@protoc_insertion_point(field_release:tinysns.NewPosting.posting)
  
  return posting_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewPosting::set_allocated_posting(::std::string* posting) {
  if (posting != NULL) {
    
  } else {
    
  }
  posting_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), posting);
  // @@protoc_insertion_point(field_set_allocated:tinysns.NewPosting.posting)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tinysns

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tinysns_2eproto__INCLUDED
